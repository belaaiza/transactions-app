# Belvo Transactions API

This project is a REST API that allows the registration of Belvo user's transactions, and provides an overview of how the users are using their money. The API is built with Django Rest Framework. 


## Running the application

This project utilizes Docker to set up the applications and its database.

To run the application locally, execute the following command inside the project directory:

```bash
docker-compose up
```
The application will run on http://127.0.0.1:8000/.

You can access http://127.0.0.1:8000/api/docs/ to browse through the available endpoints.

## Running the tests

To run the tests, execute the following command:

```bash
docker-compose run --rm app sh -c "python manage.py test"
```

## Architectural Decision Records

<br />

### **Transaction Table vs Transaction Table + User Table()**

An important design decision was the domain modeling.

Most of the information manipulated in the service is transaction information, for example: transaction reference, transaction date, etc. However, the e-mail is an user information.

Analyzing the domain in this way, it may make sense to separate the user information in another table, however, if we look at the `user_email` as the information of the transaction "maker", it can also be seen as information about the transaction.

From this perspective, and considering that for the requirements there is no need to store other user information, using a single table (Transaction) can be a good option, since it would not be necessary to do a JOIN between the User and Transaction table to generate the summary grouped by type.

<br />

### **bulk_create vs many=True + create**

Django Rest Framework allows multiple object creation through the `many=True` flag, however, the default implementantion calls `.create()` for each item in the list, and as result an INSERT is performed on the database for each item.

Another approach is to use `bulk_create()`, which inserts multiple objects on the database using only one query.

To test the performance of both approaches, a POST with 10000 records was performed.

Using `many=True` with the default implementation, the request took 13.7s.

Using `bulk_create()` the request took 7.6s.

For this reason, the solution was optimized to use `bulk_create()`.

<br />

### **Custom action vs list() for the grouped by type summary**

To build the grouped by type summary endpoint (GET /transactions?group_by=type), two approaches were analysed.

The first one was using a custom action, triggered by this specific URL.

The second one was using the default `list()` implementation and URL, and processing the "group by" feature through query params.

The second approach was chosen because it allows the use of standard endpoints generated by Django Rest Framework, such as GET /transactions to list all transactions.

Despite this, it allows the sending of other query params, for which we do not have a feature implemented, therefore, if params other than group_by=type are sent, a 501 Not Implemented is returned. The advantage of this approach is that the API is easily scalable to support other parameters, maintaining the URLs contract.


